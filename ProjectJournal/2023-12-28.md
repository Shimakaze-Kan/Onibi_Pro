# Project Journal - 2023-12-28

Today I decided to undertake a refactoring effort in the contracts of my application. So far, I have organized folders representing controllers with files for requests and responses. However, I ran into a problem with classes for nested types, as shown below:

```csharp
public record GetOrdersResponse(Guid OrderId, DateTime OrderTime, bool IsCancelled, IReadOnlyList<OrderItemDtoResponse> OrderItems, decimal Total);

public record OrderItemDtoResponse(Guid MenuItemId, int Quantity, string MenuItemName, decimal Price);
```

To avoid naming collisions with other requests, I had to name it OrderItemDtoResponse. There were even more challenging cases like `CreateRestaurantEmployeePositionResponse`. To address this problem, I decided to use nested records:

```csharp
public record GetOrdersResponse(Guid OrderId, DateTime OrderTime, bool IsCancelled,
    IReadOnlyList<OrderItem> OrderItems, decimal Total)
{
    public record OrderItem(Guid MenuItemId, int Quantity, string MenuItemName, decimal Price);
};
```

Simple and clear, without comically long names, as records are nested where nothing interferes with them. A few changes in the configuration mappings, and everything was okay. Well, almost okay because Swagger struggled with having the same record names (even if they were nested and isolated from each other). Therefore, I added a new configuration to Swagger:

```csharp
c.CustomSchemaIds(type => type.FullName?.Replace('+', '_') ?? type.Name);
```

This resolves the issue, and now I can easily use swagger.json to generate clients and classes using NSwag. So far, I haven't needed to use directly nested classes in Angular, but following the convention, the generated class would be named, for example, `GetOrdersResponse_OrderItem`. Maybe not the ideal solution, but it's clear and certainly better than before.
