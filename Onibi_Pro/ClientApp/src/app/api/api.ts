//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IAuthenticationClient {
    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterRequest | undefined): Observable<void>;
    /**
     * @param body (optional) 
     * @return Success
     */
    login(body: LoginRequest | undefined): Observable<void>;
    /**
     * @return Success
     */
    logout(): Observable<void>;
    /**
     * @return Success
     */
    isAuthenticated(): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class AuthenticationClient implements IAuthenticationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Authentication/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body: LoginRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Authentication/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    logout(): Observable<void> {
        let url_ = this.baseUrl + "/api/Authentication/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogout(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLogout(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    isAuthenticated(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Authentication/isAuthenticated";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsAuthenticated(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsAuthenticated(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsAuthenticated(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IIdentityClient {
    /**
     * @return Success
     */
    managerDetails(managerId: string): Observable<GetManagerDetailsResponse>;
    /**
     * @return Success
     */
    whoami(): Observable<GetWhoamiResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class IdentityClient implements IIdentityClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    managerDetails(managerId: string): Observable<GetManagerDetailsResponse> {
        let url_ = this.baseUrl + "/api/Identity/managerDetails/{managerId}";
        if (managerId === undefined || managerId === null)
            throw new Error("The parameter 'managerId' must be defined.");
        url_ = url_.replace("{managerId}", encodeURIComponent("" + managerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processManagerDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processManagerDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManagerDetailsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManagerDetailsResponse>;
        }));
    }

    protected processManagerDetails(response: HttpResponseBase): Observable<GetManagerDetailsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManagerDetailsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    whoami(): Observable<GetWhoamiResponse> {
        let url_ = this.baseUrl + "/api/Identity/whoami";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWhoami(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWhoami(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetWhoamiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetWhoamiResponse>;
        }));
    }

    protected processWhoami(response: HttpResponseBase): Observable<GetWhoamiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetWhoamiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IMenusClient {
    /**
     * @param body (optional) 
     * @return Success
     */
    menusPost(body: CreateMenuRequest | undefined): Observable<CreateMenuResponse>;
    /**
     * @return Success
     */
    menusGet(): Observable<GetMenusResponse[]>;
}

@Injectable({
    providedIn: 'root'
})
export class MenusClient implements IMenusClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    menusPost(body: CreateMenuRequest | undefined): Observable<CreateMenuResponse> {
        let url_ = this.baseUrl + "/api/Menus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMenusPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMenusPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateMenuResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateMenuResponse>;
        }));
    }

    protected processMenusPost(response: HttpResponseBase): Observable<CreateMenuResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateMenuResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    menusGet(): Observable<GetMenusResponse[]> {
        let url_ = this.baseUrl + "/api/Menus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMenusGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMenusGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMenusResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMenusResponse[]>;
        }));
    }

    protected processMenusGet(response: HttpResponseBase): Observable<GetMenusResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetMenusResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IOrdersClient {
    /**
     * @return Success
     */
    ordersGet(orderId: string): Observable<GetOrderByIdResponse[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    ordersPost(restaurantId: string, body: CreateOrderRequest | undefined): Observable<CreateOrderResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class OrdersClient implements IOrdersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    ordersGet(orderId: string): Observable<GetOrderByIdResponse[]> {
        let url_ = this.baseUrl + "/api/Orders/{orderId}";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrdersGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrdersGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetOrderByIdResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetOrderByIdResponse[]>;
        }));
    }

    protected processOrdersGet(response: HttpResponseBase): Observable<GetOrderByIdResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetOrderByIdResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    ordersPost(restaurantId: string, body: CreateOrderRequest | undefined): Observable<CreateOrderResponse> {
        let url_ = this.baseUrl + "/api/Orders/{restaurantId}";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrdersPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrdersPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateOrderResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateOrderResponse>;
        }));
    }

    protected processOrdersPost(response: HttpResponseBase): Observable<CreateOrderResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrderResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IRestaurantsClient {
    /**
     * @param body (optional) 
     * @return Success
     */
    restaurants(body: CreateRestaurantRequest | undefined): Observable<CreateRestaurantResponse>;
    /**
     * @param firstNameFilter (optional) 
     * @param lastNameFilter (optional) 
     * @param emailFilter (optional) 
     * @param cityFilter (optional) 
     * @param positionFilterList (optional) 
     * @return Success
     */
    employees(restaurantId: string, firstNameFilter: string | undefined, lastNameFilter: string | undefined, emailFilter: string | undefined, cityFilter: string | undefined, positionFilterList: string | undefined): Observable<GetEmployeesResponse[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    employeePost(restaurantId: string, body: CreateEmployeeRequest | undefined): Observable<CreateEmployeeResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    employeePut(restaurantId: string, body: EditEmployeeRequest | undefined): Observable<CreateEmployeeResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    manager(restaurantId: string, body: AssignManagerRequest | undefined): Observable<void>;
    /**
     * @param body (optional) 
     * @return Success
     */
    schedulePost(restaurantId: string, body: CreateScheduleRequest | undefined): Observable<void>;
    /**
     * @return Success
     */
    scheduleGet(restaurantId: string): Observable<GetScheduleResponse[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    schedulePut(restaurantId: string, body: EditScheduleRequest | undefined): Observable<void>;
    /**
     * @param body (optional) 
     * @return Success
     */
    scheduleDelete(restaurantId: string, body: DeleteScheduleRequest | undefined): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class RestaurantsClient implements IRestaurantsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    restaurants(body: CreateRestaurantRequest | undefined): Observable<CreateRestaurantResponse> {
        let url_ = this.baseUrl + "/api/Restaurants";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestaurants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestaurants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateRestaurantResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateRestaurantResponse>;
        }));
    }

    protected processRestaurants(response: HttpResponseBase): Observable<CreateRestaurantResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateRestaurantResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param firstNameFilter (optional) 
     * @param lastNameFilter (optional) 
     * @param emailFilter (optional) 
     * @param cityFilter (optional) 
     * @param positionFilterList (optional) 
     * @return Success
     */
    employees(restaurantId: string, firstNameFilter: string | undefined, lastNameFilter: string | undefined, emailFilter: string | undefined, cityFilter: string | undefined, positionFilterList: string | undefined): Observable<GetEmployeesResponse[]> {
        let url_ = this.baseUrl + "/api/Restaurants/{restaurantId}/employees?";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (firstNameFilter === null)
            throw new Error("The parameter 'firstNameFilter' cannot be null.");
        else if (firstNameFilter !== undefined)
            url_ += "FirstNameFilter=" + encodeURIComponent("" + firstNameFilter) + "&";
        if (lastNameFilter === null)
            throw new Error("The parameter 'lastNameFilter' cannot be null.");
        else if (lastNameFilter !== undefined)
            url_ += "LastNameFilter=" + encodeURIComponent("" + lastNameFilter) + "&";
        if (emailFilter === null)
            throw new Error("The parameter 'emailFilter' cannot be null.");
        else if (emailFilter !== undefined)
            url_ += "EmailFilter=" + encodeURIComponent("" + emailFilter) + "&";
        if (cityFilter === null)
            throw new Error("The parameter 'cityFilter' cannot be null.");
        else if (cityFilter !== undefined)
            url_ += "CityFilter=" + encodeURIComponent("" + cityFilter) + "&";
        if (positionFilterList === null)
            throw new Error("The parameter 'positionFilterList' cannot be null.");
        else if (positionFilterList !== undefined)
            url_ += "PositionFilterList=" + encodeURIComponent("" + positionFilterList) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployees(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetEmployeesResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetEmployeesResponse[]>;
        }));
    }

    protected processEmployees(response: HttpResponseBase): Observable<GetEmployeesResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetEmployeesResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    employeePost(restaurantId: string, body: CreateEmployeeRequest | undefined): Observable<CreateEmployeeResponse> {
        let url_ = this.baseUrl + "/api/Restaurants/{restaurantId}/employee";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployeePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployeePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateEmployeeResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateEmployeeResponse>;
        }));
    }

    protected processEmployeePost(response: HttpResponseBase): Observable<CreateEmployeeResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateEmployeeResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    employeePut(restaurantId: string, body: EditEmployeeRequest | undefined): Observable<CreateEmployeeResponse> {
        let url_ = this.baseUrl + "/api/Restaurants/{restaurantId}/employee";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployeePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployeePut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateEmployeeResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateEmployeeResponse>;
        }));
    }

    protected processEmployeePut(response: HttpResponseBase): Observable<CreateEmployeeResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateEmployeeResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    manager(restaurantId: string, body: AssignManagerRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Restaurants/{restaurantId}/manager";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processManager(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processManager(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processManager(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    schedulePost(restaurantId: string, body: CreateScheduleRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Restaurants/{restaurantId}/schedule";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSchedulePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSchedulePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSchedulePost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    scheduleGet(restaurantId: string): Observable<GetScheduleResponse[]> {
        let url_ = this.baseUrl + "/api/Restaurants/{restaurantId}/schedule";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processScheduleGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processScheduleGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetScheduleResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetScheduleResponse[]>;
        }));
    }

    protected processScheduleGet(response: HttpResponseBase): Observable<GetScheduleResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetScheduleResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    schedulePut(restaurantId: string, body: EditScheduleRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Restaurants/{restaurantId}/schedule";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSchedulePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSchedulePut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSchedulePut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    scheduleDelete(restaurantId: string, body: DeleteScheduleRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Restaurants/{restaurantId}/schedule";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processScheduleDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processScheduleDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processScheduleDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IWeatherForecastClient {
    /**
     * @return Success
     */
    weatherForecast(): Observable<WeatherForecast[]>;
    /**
     * @return Success
     */
    get(key: string): Observable<string>;
    /**
     * @return Success
     */
    set(key: string, val: string): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class WeatherForecastClient implements IWeatherForecastClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    weatherForecast(): Observable<WeatherForecast[]> {
        let url_ = this.baseUrl + "/api/WeatherForecast";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherForecast(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherForecast(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherForecast[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherForecast[]>;
        }));
    }

    protected processWeatherForecast(response: HttpResponseBase): Observable<WeatherForecast[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    get(key: string): Observable<string> {
        let url_ = this.baseUrl + "/api/WeatherForecast/get/{key}";
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    set(key: string, val: string): Observable<void> {
        let url_ = this.baseUrl + "/api/WeatherForecast/set/{key}/{val}";
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        if (val === undefined || val === null)
            throw new Error("The parameter 'val' must be defined.");
        url_ = url_.replace("{val}", encodeURIComponent("" + val));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSet(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class Address implements IAddress {
    street?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    country?: string | undefined;

    constructor(data?: IAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.street = _data["street"];
            this.city = _data["city"];
            this.postalCode = _data["postalCode"];
            this.country = _data["country"];
        }
    }

    static fromJS(data: any): Address {
        data = typeof data === 'object' ? data : {};
        let result = new Address();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["street"] = this.street;
        data["city"] = this.city;
        data["postalCode"] = this.postalCode;
        data["country"] = this.country;
        return data;
    }
}

export interface IAddress {
    street?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    country?: string | undefined;
}

export class AssignManagerRequest implements IAssignManagerRequest {
    userId?: string;

    constructor(data?: IAssignManagerRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): AssignManagerRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AssignManagerRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        return data;
    }
}

export interface IAssignManagerRequest {
    userId?: string;
}

export class CreateEmployeeRequest implements ICreateEmployeeRequest {
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    city?: string | undefined;
    employeePositions?: string[] | undefined;

    constructor(data?: ICreateEmployeeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.city = _data["city"];
            if (Array.isArray(_data["employeePositions"])) {
                this.employeePositions = [] as any;
                for (let item of _data["employeePositions"])
                    this.employeePositions!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateEmployeeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEmployeeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["city"] = this.city;
        if (Array.isArray(this.employeePositions)) {
            data["employeePositions"] = [];
            for (let item of this.employeePositions)
                data["employeePositions"].push(item);
        }
        return data;
    }
}

export interface ICreateEmployeeRequest {
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    city?: string | undefined;
    employeePositions?: string[] | undefined;
}

export class CreateEmployeeResponse implements ICreateEmployeeResponse {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    city?: string | undefined;
    employeePositions?: string[] | undefined;

    constructor(data?: ICreateEmployeeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.city = _data["city"];
            if (Array.isArray(_data["employeePositions"])) {
                this.employeePositions = [] as any;
                for (let item of _data["employeePositions"])
                    this.employeePositions!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateEmployeeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEmployeeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["city"] = this.city;
        if (Array.isArray(this.employeePositions)) {
            data["employeePositions"] = [];
            for (let item of this.employeePositions)
                data["employeePositions"].push(item);
        }
        return data;
    }
}

export interface ICreateEmployeeResponse {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    city?: string | undefined;
    employeePositions?: string[] | undefined;
}

export class CreateMenuRequest implements ICreateMenuRequest {
    name?: string | undefined;
    menuItems?: MenuItemRequest[] | undefined;

    constructor(data?: ICreateMenuRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["menuItems"])) {
                this.menuItems = [] as any;
                for (let item of _data["menuItems"])
                    this.menuItems!.push(MenuItemRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateMenuRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMenuRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.menuItems)) {
            data["menuItems"] = [];
            for (let item of this.menuItems)
                data["menuItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateMenuRequest {
    name?: string | undefined;
    menuItems?: MenuItemRequest[] | undefined;
}

export class CreateMenuResponse implements ICreateMenuResponse {
    id?: string;
    name?: string | undefined;
    menuItems?: MenuItemResponse[] | undefined;

    constructor(data?: ICreateMenuResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["menuItems"])) {
                this.menuItems = [] as any;
                for (let item of _data["menuItems"])
                    this.menuItems!.push(MenuItemResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateMenuResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMenuResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.menuItems)) {
            data["menuItems"] = [];
            for (let item of this.menuItems)
                data["menuItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateMenuResponse {
    id?: string;
    name?: string | undefined;
    menuItems?: MenuItemResponse[] | undefined;
}

export class CreateOrderRequest implements ICreateOrderRequest {
    orderItems?: OrderItemRequest[] | undefined;

    constructor(data?: ICreateOrderRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["orderItems"])) {
                this.orderItems = [] as any;
                for (let item of _data["orderItems"])
                    this.orderItems!.push(OrderItemRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateOrderRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrderRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.orderItems)) {
            data["orderItems"] = [];
            for (let item of this.orderItems)
                data["orderItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateOrderRequest {
    orderItems?: OrderItemRequest[] | undefined;
}

export class CreateOrderResponse implements ICreateOrderResponse {
    id?: string;
    dateTime?: Date;
    isCancelled?: boolean;
    orderItems?: OrderItemResponse[] | undefined;

    constructor(data?: ICreateOrderResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
            this.isCancelled = _data["isCancelled"];
            if (Array.isArray(_data["orderItems"])) {
                this.orderItems = [] as any;
                for (let item of _data["orderItems"])
                    this.orderItems!.push(OrderItemResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateOrderResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrderResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["isCancelled"] = this.isCancelled;
        if (Array.isArray(this.orderItems)) {
            data["orderItems"] = [];
            for (let item of this.orderItems)
                data["orderItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateOrderResponse {
    id?: string;
    dateTime?: Date;
    isCancelled?: boolean;
    orderItems?: OrderItemResponse[] | undefined;
}

export class CreateRestaurantEmployeePositionResponse implements ICreateRestaurantEmployeePositionResponse {
    position?: string | undefined;

    constructor(data?: ICreateRestaurantEmployeePositionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.position = _data["position"];
        }
    }

    static fromJS(data: any): CreateRestaurantEmployeePositionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRestaurantEmployeePositionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["position"] = this.position;
        return data;
    }
}

export interface ICreateRestaurantEmployeePositionResponse {
    position?: string | undefined;
}

export class CreateRestaurantEmployeeResponse implements ICreateRestaurantEmployeeResponse {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    city?: string | undefined;
    employeePositions?: CreateRestaurantEmployeePositionResponse[] | undefined;

    constructor(data?: ICreateRestaurantEmployeeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.city = _data["city"];
            if (Array.isArray(_data["employeePositions"])) {
                this.employeePositions = [] as any;
                for (let item of _data["employeePositions"])
                    this.employeePositions!.push(CreateRestaurantEmployeePositionResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateRestaurantEmployeeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRestaurantEmployeeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["city"] = this.city;
        if (Array.isArray(this.employeePositions)) {
            data["employeePositions"] = [];
            for (let item of this.employeePositions)
                data["employeePositions"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateRestaurantEmployeeResponse {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    city?: string | undefined;
    employeePositions?: CreateRestaurantEmployeePositionResponse[] | undefined;
}

export class CreateRestaurantManagerResponse implements ICreateRestaurantManagerResponse {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;

    constructor(data?: ICreateRestaurantManagerResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): CreateRestaurantManagerResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRestaurantManagerResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        return data;
    }
}

export interface ICreateRestaurantManagerResponse {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
}

export class CreateRestaurantRequest implements ICreateRestaurantRequest {
    address?: Address;
    orderIds?: string[] | undefined;
    employees?: EmployeeRequest[] | undefined;
    managers?: ManagerRequest[] | undefined;

    constructor(data?: ICreateRestaurantRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"] ? Address.fromJS(_data["address"]) : <any>undefined;
            if (Array.isArray(_data["orderIds"])) {
                this.orderIds = [] as any;
                for (let item of _data["orderIds"])
                    this.orderIds!.push(item);
            }
            if (Array.isArray(_data["employees"])) {
                this.employees = [] as any;
                for (let item of _data["employees"])
                    this.employees!.push(EmployeeRequest.fromJS(item));
            }
            if (Array.isArray(_data["managers"])) {
                this.managers = [] as any;
                for (let item of _data["managers"])
                    this.managers!.push(ManagerRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateRestaurantRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRestaurantRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        if (Array.isArray(this.orderIds)) {
            data["orderIds"] = [];
            for (let item of this.orderIds)
                data["orderIds"].push(item);
        }
        if (Array.isArray(this.employees)) {
            data["employees"] = [];
            for (let item of this.employees)
                data["employees"].push(item.toJSON());
        }
        if (Array.isArray(this.managers)) {
            data["managers"] = [];
            for (let item of this.managers)
                data["managers"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateRestaurantRequest {
    address?: Address;
    orderIds?: string[] | undefined;
    employees?: EmployeeRequest[] | undefined;
    managers?: ManagerRequest[] | undefined;
}

export class CreateRestaurantResponse implements ICreateRestaurantResponse {
    id?: string;
    address?: Address;
    orderIds?: string[] | undefined;
    employees?: CreateRestaurantEmployeeResponse[] | undefined;
    managers?: CreateRestaurantManagerResponse[] | undefined;

    constructor(data?: ICreateRestaurantResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.address = _data["address"] ? Address.fromJS(_data["address"]) : <any>undefined;
            if (Array.isArray(_data["orderIds"])) {
                this.orderIds = [] as any;
                for (let item of _data["orderIds"])
                    this.orderIds!.push(item);
            }
            if (Array.isArray(_data["employees"])) {
                this.employees = [] as any;
                for (let item of _data["employees"])
                    this.employees!.push(CreateRestaurantEmployeeResponse.fromJS(item));
            }
            if (Array.isArray(_data["managers"])) {
                this.managers = [] as any;
                for (let item of _data["managers"])
                    this.managers!.push(CreateRestaurantManagerResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateRestaurantResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRestaurantResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        if (Array.isArray(this.orderIds)) {
            data["orderIds"] = [];
            for (let item of this.orderIds)
                data["orderIds"].push(item);
        }
        if (Array.isArray(this.employees)) {
            data["employees"] = [];
            for (let item of this.employees)
                data["employees"].push(item.toJSON());
        }
        if (Array.isArray(this.managers)) {
            data["managers"] = [];
            for (let item of this.managers)
                data["managers"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateRestaurantResponse {
    id?: string;
    address?: Address;
    orderIds?: string[] | undefined;
    employees?: CreateRestaurantEmployeeResponse[] | undefined;
    managers?: CreateRestaurantManagerResponse[] | undefined;
}

export class CreateScheduleRequest implements ICreateScheduleRequest {
    title?: string | undefined;
    priority?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    employeeIds?: string[] | undefined;

    constructor(data?: ICreateScheduleRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.priority = _data["priority"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["employeeIds"])) {
                this.employeeIds = [] as any;
                for (let item of _data["employeeIds"])
                    this.employeeIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateScheduleRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateScheduleRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["priority"] = this.priority;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        if (Array.isArray(this.employeeIds)) {
            data["employeeIds"] = [];
            for (let item of this.employeeIds)
                data["employeeIds"].push(item);
        }
        return data;
    }
}

export interface ICreateScheduleRequest {
    title?: string | undefined;
    priority?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    employeeIds?: string[] | undefined;
}

export class DeleteScheduleRequest implements IDeleteScheduleRequest {
    scheduleId?: string;

    constructor(data?: IDeleteScheduleRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scheduleId = _data["scheduleId"];
        }
    }

    static fromJS(data: any): DeleteScheduleRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteScheduleRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scheduleId"] = this.scheduleId;
        return data;
    }
}

export interface IDeleteScheduleRequest {
    scheduleId?: string;
}

export class EditEmployeeRequest implements IEditEmployeeRequest {
    employeeId?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    city?: string | undefined;
    employeePositions?: string[] | undefined;

    constructor(data?: IEditEmployeeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeId = _data["employeeId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.city = _data["city"];
            if (Array.isArray(_data["employeePositions"])) {
                this.employeePositions = [] as any;
                for (let item of _data["employeePositions"])
                    this.employeePositions!.push(item);
            }
        }
    }

    static fromJS(data: any): EditEmployeeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EditEmployeeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeId"] = this.employeeId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["city"] = this.city;
        if (Array.isArray(this.employeePositions)) {
            data["employeePositions"] = [];
            for (let item of this.employeePositions)
                data["employeePositions"].push(item);
        }
        return data;
    }
}

export interface IEditEmployeeRequest {
    employeeId?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    city?: string | undefined;
    employeePositions?: string[] | undefined;
}

export class EditScheduleRequest implements IEditScheduleRequest {
    scheduleId?: string;
    title?: string | undefined;
    priority?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    employeeIds?: string[] | undefined;

    constructor(data?: IEditScheduleRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scheduleId = _data["scheduleId"];
            this.title = _data["title"];
            this.priority = _data["priority"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["employeeIds"])) {
                this.employeeIds = [] as any;
                for (let item of _data["employeeIds"])
                    this.employeeIds!.push(item);
            }
        }
    }

    static fromJS(data: any): EditScheduleRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EditScheduleRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scheduleId"] = this.scheduleId;
        data["title"] = this.title;
        data["priority"] = this.priority;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        if (Array.isArray(this.employeeIds)) {
            data["employeeIds"] = [];
            for (let item of this.employeeIds)
                data["employeeIds"].push(item);
        }
        return data;
    }
}

export interface IEditScheduleRequest {
    scheduleId?: string;
    title?: string | undefined;
    priority?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    employeeIds?: string[] | undefined;
}

export class EmployeePositionRequest implements IEmployeePositionRequest {
    position?: string | undefined;

    constructor(data?: IEmployeePositionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.position = _data["position"];
        }
    }

    static fromJS(data: any): EmployeePositionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeePositionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["position"] = this.position;
        return data;
    }
}

export interface IEmployeePositionRequest {
    position?: string | undefined;
}

export class EmployeeRequest implements IEmployeeRequest {
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    city?: string | undefined;
    employeePositions?: EmployeePositionRequest[] | undefined;

    constructor(data?: IEmployeeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.city = _data["city"];
            if (Array.isArray(_data["employeePositions"])) {
                this.employeePositions = [] as any;
                for (let item of _data["employeePositions"])
                    this.employeePositions!.push(EmployeePositionRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EmployeeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["city"] = this.city;
        if (Array.isArray(this.employeePositions)) {
            data["employeePositions"] = [];
            for (let item of this.employeePositions)
                data["employeePositions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEmployeeRequest {
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    city?: string | undefined;
    employeePositions?: EmployeePositionRequest[] | undefined;
}

export class GetEmployeesResponse implements IGetEmployeesResponse {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    city?: string | undefined;
    supervisors?: string | undefined;
    positions?: string[] | undefined;

    constructor(data?: IGetEmployeesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.city = _data["city"];
            this.supervisors = _data["supervisors"];
            if (Array.isArray(_data["positions"])) {
                this.positions = [] as any;
                for (let item of _data["positions"])
                    this.positions!.push(item);
            }
        }
    }

    static fromJS(data: any): GetEmployeesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetEmployeesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["city"] = this.city;
        data["supervisors"] = this.supervisors;
        if (Array.isArray(this.positions)) {
            data["positions"] = [];
            for (let item of this.positions)
                data["positions"].push(item);
        }
        return data;
    }
}

export interface IGetEmployeesResponse {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    city?: string | undefined;
    supervisors?: string | undefined;
    positions?: string[] | undefined;
}

export class GetIngredientResponse implements IGetIngredientResponse {
    name?: string | undefined;
    unit?: string | undefined;
    quantity?: number;

    constructor(data?: IGetIngredientResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.unit = _data["unit"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): GetIngredientResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetIngredientResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["unit"] = this.unit;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface IGetIngredientResponse {
    name?: string | undefined;
    unit?: string | undefined;
    quantity?: number;
}

export class GetManagerDetailsManagerNamesResponse implements IGetManagerDetailsManagerNamesResponse {
    firstName?: string | undefined;
    lastName?: string | undefined;

    constructor(data?: IGetManagerDetailsManagerNamesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): GetManagerDetailsManagerNamesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetManagerDetailsManagerNamesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data;
    }
}

export interface IGetManagerDetailsManagerNamesResponse {
    firstName?: string | undefined;
    lastName?: string | undefined;
}

export class GetManagerDetailsResponse implements IGetManagerDetailsResponse {
    restaurantId?: string;
    sameRestaurantManagers?: GetManagerDetailsManagerNamesResponse[] | undefined;

    constructor(data?: IGetManagerDetailsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.restaurantId = _data["restaurantId"];
            if (Array.isArray(_data["sameRestaurantManagers"])) {
                this.sameRestaurantManagers = [] as any;
                for (let item of _data["sameRestaurantManagers"])
                    this.sameRestaurantManagers!.push(GetManagerDetailsManagerNamesResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetManagerDetailsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetManagerDetailsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["restaurantId"] = this.restaurantId;
        if (Array.isArray(this.sameRestaurantManagers)) {
            data["sameRestaurantManagers"] = [];
            for (let item of this.sameRestaurantManagers)
                data["sameRestaurantManagers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetManagerDetailsResponse {
    restaurantId?: string;
    sameRestaurantManagers?: GetManagerDetailsManagerNamesResponse[] | undefined;
}

export class GetMenuItemResponse implements IGetMenuItemResponse {
    menuItemId?: string;
    name?: string | undefined;
    price?: number;
    ingredients?: GetIngredientResponse[] | undefined;

    constructor(data?: IGetMenuItemResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.menuItemId = _data["menuItemId"];
            this.name = _data["name"];
            this.price = _data["price"];
            if (Array.isArray(_data["ingredients"])) {
                this.ingredients = [] as any;
                for (let item of _data["ingredients"])
                    this.ingredients!.push(GetIngredientResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetMenuItemResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetMenuItemResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["menuItemId"] = this.menuItemId;
        data["name"] = this.name;
        data["price"] = this.price;
        if (Array.isArray(this.ingredients)) {
            data["ingredients"] = [];
            for (let item of this.ingredients)
                data["ingredients"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetMenuItemResponse {
    menuItemId?: string;
    name?: string | undefined;
    price?: number;
    ingredients?: GetIngredientResponse[] | undefined;
}

export class GetMenusResponse implements IGetMenusResponse {
    id?: string;
    name?: string | undefined;
    menuItems?: GetMenuItemResponse[] | undefined;

    constructor(data?: IGetMenusResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["menuItems"])) {
                this.menuItems = [] as any;
                for (let item of _data["menuItems"])
                    this.menuItems!.push(GetMenuItemResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetMenusResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetMenusResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.menuItems)) {
            data["menuItems"] = [];
            for (let item of this.menuItems)
                data["menuItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetMenusResponse {
    id?: string;
    name?: string | undefined;
    menuItems?: GetMenuItemResponse[] | undefined;
}

export class GetOrderByIdResponse implements IGetOrderByIdResponse {
    name?: string | undefined;
    quantity?: number;
    orderTime?: Date;
    isCancelled?: boolean;

    constructor(data?: IGetOrderByIdResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.quantity = _data["quantity"];
            this.orderTime = _data["orderTime"] ? new Date(_data["orderTime"].toString()) : <any>undefined;
            this.isCancelled = _data["isCancelled"];
        }
    }

    static fromJS(data: any): GetOrderByIdResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetOrderByIdResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["quantity"] = this.quantity;
        data["orderTime"] = this.orderTime ? this.orderTime.toISOString() : <any>undefined;
        data["isCancelled"] = this.isCancelled;
        return data;
    }
}

export interface IGetOrderByIdResponse {
    name?: string | undefined;
    quantity?: number;
    orderTime?: Date;
    isCancelled?: boolean;
}

export class GetScheduleResponse implements IGetScheduleResponse {
    scheduleId?: string;
    title?: string | undefined;
    priority?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    employeeIds?: string[] | undefined;

    constructor(data?: IGetScheduleResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scheduleId = _data["scheduleId"];
            this.title = _data["title"];
            this.priority = _data["priority"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["employeeIds"])) {
                this.employeeIds = [] as any;
                for (let item of _data["employeeIds"])
                    this.employeeIds!.push(item);
            }
        }
    }

    static fromJS(data: any): GetScheduleResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetScheduleResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scheduleId"] = this.scheduleId;
        data["title"] = this.title;
        data["priority"] = this.priority;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        if (Array.isArray(this.employeeIds)) {
            data["employeeIds"] = [];
            for (let item of this.employeeIds)
                data["employeeIds"].push(item);
        }
        return data;
    }
}

export interface IGetScheduleResponse {
    scheduleId?: string;
    title?: string | undefined;
    priority?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    employeeIds?: string[] | undefined;
}

export class GetWhoamiResponse implements IGetWhoamiResponse {
    userId?: string;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    userType?: string | undefined;

    constructor(data?: IGetWhoamiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.userType = _data["userType"];
        }
    }

    static fromJS(data: any): GetWhoamiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetWhoamiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["userType"] = this.userType;
        return data;
    }
}

export interface IGetWhoamiResponse {
    userId?: string;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    userType?: string | undefined;
}

export class IngredientRequest implements IIngredientRequest {
    name?: string | undefined;
    unit?: string | undefined;
    quantity?: number;

    constructor(data?: IIngredientRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.unit = _data["unit"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): IngredientRequest {
        data = typeof data === 'object' ? data : {};
        let result = new IngredientRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["unit"] = this.unit;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface IIngredientRequest {
    name?: string | undefined;
    unit?: string | undefined;
    quantity?: number;
}

export class IngredientResponse implements IIngredientResponse {
    name?: string | undefined;
    unit?: string | undefined;
    quantity?: number;

    constructor(data?: IIngredientResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.unit = _data["unit"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): IngredientResponse {
        data = typeof data === 'object' ? data : {};
        let result = new IngredientResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["unit"] = this.unit;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface IIngredientResponse {
    name?: string | undefined;
    unit?: string | undefined;
    quantity?: number;
}

export class LoginRequest implements ILoginRequest {
    email?: string | undefined;
    password?: string | undefined;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginRequest {
    email?: string | undefined;
    password?: string | undefined;
}

export class ManagerRequest implements IManagerRequest {
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;

    constructor(data?: IManagerRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ManagerRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ManagerRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        return data;
    }
}

export interface IManagerRequest {
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
}

export class MenuItemRequest implements IMenuItemRequest {
    name?: string | undefined;
    price?: number;
    ingredients?: IngredientRequest[] | undefined;

    constructor(data?: IMenuItemRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.price = _data["price"];
            if (Array.isArray(_data["ingredients"])) {
                this.ingredients = [] as any;
                for (let item of _data["ingredients"])
                    this.ingredients!.push(IngredientRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MenuItemRequest {
        data = typeof data === 'object' ? data : {};
        let result = new MenuItemRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["price"] = this.price;
        if (Array.isArray(this.ingredients)) {
            data["ingredients"] = [];
            for (let item of this.ingredients)
                data["ingredients"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMenuItemRequest {
    name?: string | undefined;
    price?: number;
    ingredients?: IngredientRequest[] | undefined;
}

export class MenuItemResponse implements IMenuItemResponse {
    id?: string;
    name?: string | undefined;
    price?: number;
    ingredients?: IngredientResponse[] | undefined;

    constructor(data?: IMenuItemResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.price = _data["price"];
            if (Array.isArray(_data["ingredients"])) {
                this.ingredients = [] as any;
                for (let item of _data["ingredients"])
                    this.ingredients!.push(IngredientResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MenuItemResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MenuItemResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["price"] = this.price;
        if (Array.isArray(this.ingredients)) {
            data["ingredients"] = [];
            for (let item of this.ingredients)
                data["ingredients"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMenuItemResponse {
    id?: string;
    name?: string | undefined;
    price?: number;
    ingredients?: IngredientResponse[] | undefined;
}

export class OrderItemRequest implements IOrderItemRequest {
    quantity?: number;
    menuItemId?: string;

    constructor(data?: IOrderItemRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.quantity = _data["quantity"];
            this.menuItemId = _data["menuItemId"];
        }
    }

    static fromJS(data: any): OrderItemRequest {
        data = typeof data === 'object' ? data : {};
        let result = new OrderItemRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quantity"] = this.quantity;
        data["menuItemId"] = this.menuItemId;
        return data;
    }
}

export interface IOrderItemRequest {
    quantity?: number;
    menuItemId?: string;
}

export class OrderItemResponse implements IOrderItemResponse {
    menuItemId?: string;
    quantity?: number;

    constructor(data?: IOrderItemResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.menuItemId = _data["menuItemId"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): OrderItemResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OrderItemResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["menuItemId"] = this.menuItemId;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface IOrderItemResponse {
    menuItemId?: string;
    quantity?: number;
}

export class RegisterRequest implements IRegisterRequest {
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;

    constructor(data?: IRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): RegisterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface IRegisterRequest {
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
}

export class WeatherForecast implements IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    readonly temperatureF?: number;
    summary?: string | undefined;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.temperatureC = _data["temperatureC"];
            (<any>this).temperatureF = _data["temperatureF"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? formatDate(this.date) : <any>undefined;
        data["temperatureC"] = this.temperatureC;
        data["temperatureF"] = this.temperatureF;
        data["summary"] = this.summary;
        return data;
    }
}

export interface IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}