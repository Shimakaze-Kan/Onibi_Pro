//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IAuthenticationClient {
    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterRequest | undefined): Observable<void>;
    /**
     * @param body (optional) 
     * @return Success
     */
    login(body: LoginRequest | undefined): Observable<void>;
    /**
     * @return Success
     */
    logout(): Observable<void>;
    /**
     * @return Success
     */
    isAuthenticated(): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class AuthenticationClient implements IAuthenticationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Authentication/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body: LoginRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Authentication/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    logout(): Observable<void> {
        let url_ = this.baseUrl + "/api/Authentication/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogout(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLogout(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    isAuthenticated(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Authentication/isAuthenticated";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsAuthenticated(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsAuthenticated(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsAuthenticated(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IIdentityClient {
    /**
     * @return Success
     */
    managerDetails(managerId: string): Observable<GetManagerDetailsResponse>;
    /**
     * @return Success
     */
    whoami(): Observable<GetWhoamiResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class IdentityClient implements IIdentityClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    managerDetails(managerId: string): Observable<GetManagerDetailsResponse> {
        let url_ = this.baseUrl + "/api/Identity/managerDetails/{managerId}";
        if (managerId === undefined || managerId === null)
            throw new Error("The parameter 'managerId' must be defined.");
        url_ = url_.replace("{managerId}", encodeURIComponent("" + managerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processManagerDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processManagerDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManagerDetailsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManagerDetailsResponse>;
        }));
    }

    protected processManagerDetails(response: HttpResponseBase): Observable<GetManagerDetailsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManagerDetailsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    whoami(): Observable<GetWhoamiResponse> {
        let url_ = this.baseUrl + "/api/Identity/whoami";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWhoami(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWhoami(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetWhoamiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetWhoamiResponse>;
        }));
    }

    protected processWhoami(response: HttpResponseBase): Observable<GetWhoamiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetWhoamiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IMenusClient {
    /**
     * @param body (optional) 
     * @return Success
     */
    menusPost(body: CreateMenuRequest | undefined): Observable<CreateMenuResponse>;
    /**
     * @return Success
     */
    menusGet(): Observable<GetMenusResponse[]>;
    /**
     * @return Success
     */
    ingredients(): Observable<GetIngredientResponse[]>;
}

@Injectable({
    providedIn: 'root'
})
export class MenusClient implements IMenusClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    menusPost(body: CreateMenuRequest | undefined): Observable<CreateMenuResponse> {
        let url_ = this.baseUrl + "/api/Menus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMenusPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMenusPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateMenuResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateMenuResponse>;
        }));
    }

    protected processMenusPost(response: HttpResponseBase): Observable<CreateMenuResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateMenuResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    menusGet(): Observable<GetMenusResponse[]> {
        let url_ = this.baseUrl + "/api/Menus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMenusGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMenusGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMenusResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMenusResponse[]>;
        }));
    }

    protected processMenusGet(response: HttpResponseBase): Observable<GetMenusResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetMenusResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    ingredients(): Observable<GetIngredientResponse[]> {
        let url_ = this.baseUrl + "/api/Menus/ingredients";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIngredients(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIngredients(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetIngredientResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetIngredientResponse[]>;
        }));
    }

    protected processIngredients(response: HttpResponseBase): Observable<GetIngredientResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetIngredientResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IOrdersClient {
    /**
     * @return Success
     */
    id(orderId: string): Observable<GetOrderByIdResponse[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    ordersPost(restaurantId: string, body: CreateOrderRequest | undefined): Observable<CreateOrderResponse>;
    /**
     * @param startRow (optional) 
     * @param amount (optional) 
     * @return Success
     */
    ordersGet(startRow: number | undefined, amount: number | undefined): Observable<GetOrdersResponse>;
    /**
     * @return Success
     */
    ordersPut(orderId: string): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class OrdersClient implements IOrdersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    id(orderId: string): Observable<GetOrderByIdResponse[]> {
        let url_ = this.baseUrl + "/api/Orders/id/{orderId}";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetOrderByIdResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetOrderByIdResponse[]>;
        }));
    }

    protected processId(response: HttpResponseBase): Observable<GetOrderByIdResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetOrderByIdResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    ordersPost(restaurantId: string, body: CreateOrderRequest | undefined): Observable<CreateOrderResponse> {
        let url_ = this.baseUrl + "/api/Orders/{restaurantId}";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrdersPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrdersPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateOrderResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateOrderResponse>;
        }));
    }

    protected processOrdersPost(response: HttpResponseBase): Observable<CreateOrderResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrderResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param startRow (optional) 
     * @param amount (optional) 
     * @return Success
     */
    ordersGet(startRow: number | undefined, amount: number | undefined): Observable<GetOrdersResponse> {
        let url_ = this.baseUrl + "/api/Orders?";
        if (startRow === null)
            throw new Error("The parameter 'startRow' cannot be null.");
        else if (startRow !== undefined)
            url_ += "StartRow=" + encodeURIComponent("" + startRow) + "&";
        if (amount === null)
            throw new Error("The parameter 'amount' cannot be null.");
        else if (amount !== undefined)
            url_ += "Amount=" + encodeURIComponent("" + amount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrdersGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrdersGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetOrdersResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetOrdersResponse>;
        }));
    }

    protected processOrdersGet(response: HttpResponseBase): Observable<GetOrdersResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetOrdersResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    ordersPut(orderId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Orders/{orderId}";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrdersPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrdersPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOrdersPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IRestaurantsClient {
    /**
     * @param body (optional) 
     * @return Success
     */
    restaurants(body: CreateRestaurantRequest | undefined): Observable<CreateRestaurantResponse>;
    /**
     * @param firstNameFilter (optional) 
     * @param lastNameFilter (optional) 
     * @param emailFilter (optional) 
     * @param cityFilter (optional) 
     * @param positionFilterList (optional) 
     * @return Success
     */
    employees(restaurantId: string, firstNameFilter: string | undefined, lastNameFilter: string | undefined, emailFilter: string | undefined, cityFilter: string | undefined, positionFilterList: string | undefined): Observable<GetEmployeesResponse[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    employeePost(restaurantId: string, body: CreateEmployeeRequest | undefined): Observable<CreateEmployeeResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    employeePut(restaurantId: string, body: EditEmployeeRequest | undefined): Observable<CreateEmployeeResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    manager(restaurantId: string, body: AssignManagerRequest | undefined): Observable<void>;
    /**
     * @param body (optional) 
     * @return Success
     */
    schedulePost(restaurantId: string, body: CreateScheduleRequest | undefined): Observable<void>;
    /**
     * @return Success
     */
    scheduleGet(restaurantId: string): Observable<GetScheduleResponse[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    schedulePut(restaurantId: string, body: EditScheduleRequest | undefined): Observable<void>;
    /**
     * @param body (optional) 
     * @return Success
     */
    scheduleDelete(restaurantId: string, body: DeleteScheduleRequest | undefined): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class RestaurantsClient implements IRestaurantsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    restaurants(body: CreateRestaurantRequest | undefined): Observable<CreateRestaurantResponse> {
        let url_ = this.baseUrl + "/api/Restaurants";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestaurants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestaurants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateRestaurantResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateRestaurantResponse>;
        }));
    }

    protected processRestaurants(response: HttpResponseBase): Observable<CreateRestaurantResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateRestaurantResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param firstNameFilter (optional) 
     * @param lastNameFilter (optional) 
     * @param emailFilter (optional) 
     * @param cityFilter (optional) 
     * @param positionFilterList (optional) 
     * @return Success
     */
    employees(restaurantId: string, firstNameFilter: string | undefined, lastNameFilter: string | undefined, emailFilter: string | undefined, cityFilter: string | undefined, positionFilterList: string | undefined): Observable<GetEmployeesResponse[]> {
        let url_ = this.baseUrl + "/api/Restaurants/{restaurantId}/employees?";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (firstNameFilter === null)
            throw new Error("The parameter 'firstNameFilter' cannot be null.");
        else if (firstNameFilter !== undefined)
            url_ += "FirstNameFilter=" + encodeURIComponent("" + firstNameFilter) + "&";
        if (lastNameFilter === null)
            throw new Error("The parameter 'lastNameFilter' cannot be null.");
        else if (lastNameFilter !== undefined)
            url_ += "LastNameFilter=" + encodeURIComponent("" + lastNameFilter) + "&";
        if (emailFilter === null)
            throw new Error("The parameter 'emailFilter' cannot be null.");
        else if (emailFilter !== undefined)
            url_ += "EmailFilter=" + encodeURIComponent("" + emailFilter) + "&";
        if (cityFilter === null)
            throw new Error("The parameter 'cityFilter' cannot be null.");
        else if (cityFilter !== undefined)
            url_ += "CityFilter=" + encodeURIComponent("" + cityFilter) + "&";
        if (positionFilterList === null)
            throw new Error("The parameter 'positionFilterList' cannot be null.");
        else if (positionFilterList !== undefined)
            url_ += "PositionFilterList=" + encodeURIComponent("" + positionFilterList) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployees(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetEmployeesResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetEmployeesResponse[]>;
        }));
    }

    protected processEmployees(response: HttpResponseBase): Observable<GetEmployeesResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetEmployeesResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    employeePost(restaurantId: string, body: CreateEmployeeRequest | undefined): Observable<CreateEmployeeResponse> {
        let url_ = this.baseUrl + "/api/Restaurants/{restaurantId}/employee";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployeePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployeePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateEmployeeResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateEmployeeResponse>;
        }));
    }

    protected processEmployeePost(response: HttpResponseBase): Observable<CreateEmployeeResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateEmployeeResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    employeePut(restaurantId: string, body: EditEmployeeRequest | undefined): Observable<CreateEmployeeResponse> {
        let url_ = this.baseUrl + "/api/Restaurants/{restaurantId}/employee";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployeePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployeePut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateEmployeeResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateEmployeeResponse>;
        }));
    }

    protected processEmployeePut(response: HttpResponseBase): Observable<CreateEmployeeResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateEmployeeResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    manager(restaurantId: string, body: AssignManagerRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Restaurants/{restaurantId}/manager";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processManager(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processManager(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processManager(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    schedulePost(restaurantId: string, body: CreateScheduleRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Restaurants/{restaurantId}/schedule";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSchedulePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSchedulePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSchedulePost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    scheduleGet(restaurantId: string): Observable<GetScheduleResponse[]> {
        let url_ = this.baseUrl + "/api/Restaurants/{restaurantId}/schedule";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processScheduleGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processScheduleGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetScheduleResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetScheduleResponse[]>;
        }));
    }

    protected processScheduleGet(response: HttpResponseBase): Observable<GetScheduleResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetScheduleResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    schedulePut(restaurantId: string, body: EditScheduleRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Restaurants/{restaurantId}/schedule";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSchedulePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSchedulePut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSchedulePut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    scheduleDelete(restaurantId: string, body: DeleteScheduleRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Restaurants/{restaurantId}/schedule";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processScheduleDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processScheduleDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processScheduleDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IShipmentsClient {
    /**
     * @param body (optional) 
     * @return Success
     */
    shipmentsPost(body: CreatePackageRequest | undefined): Observable<PackageItem>;
    /**
     * @param startRow (optional) 
     * @param amount (optional) 
     * @return Success
     */
    shipmentsGet(startRow: number | undefined, amount: number | undefined): Observable<GetPackagesResponse>;
    /**
     * @return Success
     */
    id(packageId: string): Observable<PackageItem>;
}

@Injectable({
    providedIn: 'root'
})
export class ShipmentsClient implements IShipmentsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    shipmentsPost(body: CreatePackageRequest | undefined): Observable<PackageItem> {
        let url_ = this.baseUrl + "/api/Shipments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShipmentsPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShipmentsPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PackageItem>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PackageItem>;
        }));
    }

    protected processShipmentsPost(response: HttpResponseBase): Observable<PackageItem> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PackageItem.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param startRow (optional) 
     * @param amount (optional) 
     * @return Success
     */
    shipmentsGet(startRow: number | undefined, amount: number | undefined): Observable<GetPackagesResponse> {
        let url_ = this.baseUrl + "/api/Shipments?";
        if (startRow === null)
            throw new Error("The parameter 'startRow' cannot be null.");
        else if (startRow !== undefined)
            url_ += "StartRow=" + encodeURIComponent("" + startRow) + "&";
        if (amount === null)
            throw new Error("The parameter 'amount' cannot be null.");
        else if (amount !== undefined)
            url_ += "Amount=" + encodeURIComponent("" + amount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShipmentsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShipmentsGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPackagesResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPackagesResponse>;
        }));
    }

    protected processShipmentsGet(response: HttpResponseBase): Observable<GetPackagesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPackagesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    id(packageId: string): Observable<PackageItem> {
        let url_ = this.baseUrl + "/api/Shipments/id/{packageId}";
        if (packageId === undefined || packageId === null)
            throw new Error("The parameter 'packageId' must be defined.");
        url_ = url_.replace("{packageId}", encodeURIComponent("" + packageId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PackageItem>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PackageItem>;
        }));
    }

    protected processId(response: HttpResponseBase): Observable<PackageItem> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PackageItem.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IWeatherForecastClient {
    /**
     * @return Success
     */
    weatherForecast(): Observable<WeatherForecast[]>;
    /**
     * @return Success
     */
    get(key: string): Observable<string>;
    /**
     * @return Success
     */
    set(key: string, val: string): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class WeatherForecastClient implements IWeatherForecastClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    weatherForecast(): Observable<WeatherForecast[]> {
        let url_ = this.baseUrl + "/api/WeatherForecast";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherForecast(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherForecast(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherForecast[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherForecast[]>;
        }));
    }

    protected processWeatherForecast(response: HttpResponseBase): Observable<WeatherForecast[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    get(key: string): Observable<string> {
        let url_ = this.baseUrl + "/api/WeatherForecast/get/{key}";
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    set(key: string, val: string): Observable<void> {
        let url_ = this.baseUrl + "/api/WeatherForecast/set/{key}/{val}";
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        if (val === undefined || val === null)
            throw new Error("The parameter 'val' must be defined.");
        url_ = url_.replace("{val}", encodeURIComponent("" + val));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSet(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class LoginRequest implements ILoginRequest {
    email?: string | undefined;
    password?: string | undefined;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginRequest {
    email?: string | undefined;
    password?: string | undefined;
}

export class RegisterRequest implements IRegisterRequest {
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;

    constructor(data?: IRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): RegisterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface IRegisterRequest {
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
}

export class Address implements IAddress {
    street?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    country?: string | undefined;

    constructor(data?: IAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.street = _data["street"];
            this.city = _data["city"];
            this.postalCode = _data["postalCode"];
            this.country = _data["country"];
        }
    }

    static fromJS(data: any): Address {
        data = typeof data === 'object' ? data : {};
        let result = new Address();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["street"] = this.street;
        data["city"] = this.city;
        data["postalCode"] = this.postalCode;
        data["country"] = this.country;
        return data;
    }
}

export interface IAddress {
    street?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    country?: string | undefined;
}

export class GetManagerDetailsResponse implements IGetManagerDetailsResponse {
    managerId?: string;
    restaurantId?: string;
    sameRestaurantManagers?: GetManagerDetailsResponse_ManagerName[] | undefined;

    constructor(data?: IGetManagerDetailsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.managerId = _data["managerId"];
            this.restaurantId = _data["restaurantId"];
            if (Array.isArray(_data["sameRestaurantManagers"])) {
                this.sameRestaurantManagers = [] as any;
                for (let item of _data["sameRestaurantManagers"])
                    this.sameRestaurantManagers!.push(GetManagerDetailsResponse_ManagerName.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetManagerDetailsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetManagerDetailsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["managerId"] = this.managerId;
        data["restaurantId"] = this.restaurantId;
        if (Array.isArray(this.sameRestaurantManagers)) {
            data["sameRestaurantManagers"] = [];
            for (let item of this.sameRestaurantManagers)
                data["sameRestaurantManagers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetManagerDetailsResponse {
    managerId?: string;
    restaurantId?: string;
    sameRestaurantManagers?: GetManagerDetailsResponse_ManagerName[] | undefined;
}

export class GetManagerDetailsResponse_ManagerName implements IGetManagerDetailsResponse_ManagerName {
    firstName?: string | undefined;
    lastName?: string | undefined;

    constructor(data?: IGetManagerDetailsResponse_ManagerName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): GetManagerDetailsResponse_ManagerName {
        data = typeof data === 'object' ? data : {};
        let result = new GetManagerDetailsResponse_ManagerName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data;
    }
}

export interface IGetManagerDetailsResponse_ManagerName {
    firstName?: string | undefined;
    lastName?: string | undefined;
}

export class GetWhoamiResponse implements IGetWhoamiResponse {
    userId?: string;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    userType?: string | undefined;

    constructor(data?: IGetWhoamiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.userType = _data["userType"];
        }
    }

    static fromJS(data: any): GetWhoamiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetWhoamiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["userType"] = this.userType;
        return data;
    }
}

export interface IGetWhoamiResponse {
    userId?: string;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    userType?: string | undefined;
}

export class CreateMenuRequest implements ICreateMenuRequest {
    name?: string | undefined;
    menuItems?: CreateMenuRequest_MenuItem[] | undefined;

    constructor(data?: ICreateMenuRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["menuItems"])) {
                this.menuItems = [] as any;
                for (let item of _data["menuItems"])
                    this.menuItems!.push(CreateMenuRequest_MenuItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateMenuRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMenuRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.menuItems)) {
            data["menuItems"] = [];
            for (let item of this.menuItems)
                data["menuItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateMenuRequest {
    name?: string | undefined;
    menuItems?: CreateMenuRequest_MenuItem[] | undefined;
}

export class CreateMenuRequest_Ingredient implements ICreateMenuRequest_Ingredient {
    name?: string | undefined;
    unit?: string | undefined;
    quantity?: number;

    constructor(data?: ICreateMenuRequest_Ingredient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.unit = _data["unit"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): CreateMenuRequest_Ingredient {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMenuRequest_Ingredient();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["unit"] = this.unit;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface ICreateMenuRequest_Ingredient {
    name?: string | undefined;
    unit?: string | undefined;
    quantity?: number;
}

export class CreateMenuRequest_MenuItem implements ICreateMenuRequest_MenuItem {
    name?: string | undefined;
    price?: number;
    ingredients?: CreateMenuRequest_Ingredient[] | undefined;

    constructor(data?: ICreateMenuRequest_MenuItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.price = _data["price"];
            if (Array.isArray(_data["ingredients"])) {
                this.ingredients = [] as any;
                for (let item of _data["ingredients"])
                    this.ingredients!.push(CreateMenuRequest_Ingredient.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateMenuRequest_MenuItem {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMenuRequest_MenuItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["price"] = this.price;
        if (Array.isArray(this.ingredients)) {
            data["ingredients"] = [];
            for (let item of this.ingredients)
                data["ingredients"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateMenuRequest_MenuItem {
    name?: string | undefined;
    price?: number;
    ingredients?: CreateMenuRequest_Ingredient[] | undefined;
}

export class CreateMenuResponse implements ICreateMenuResponse {
    id?: string;
    name?: string | undefined;
    menuItems?: CreateMenuResponse_MenuItem[] | undefined;

    constructor(data?: ICreateMenuResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["menuItems"])) {
                this.menuItems = [] as any;
                for (let item of _data["menuItems"])
                    this.menuItems!.push(CreateMenuResponse_MenuItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateMenuResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMenuResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.menuItems)) {
            data["menuItems"] = [];
            for (let item of this.menuItems)
                data["menuItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateMenuResponse {
    id?: string;
    name?: string | undefined;
    menuItems?: CreateMenuResponse_MenuItem[] | undefined;
}

export class CreateMenuResponse_Ingredient implements ICreateMenuResponse_Ingredient {
    name?: string | undefined;
    unit?: string | undefined;
    quantity?: number;

    constructor(data?: ICreateMenuResponse_Ingredient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.unit = _data["unit"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): CreateMenuResponse_Ingredient {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMenuResponse_Ingredient();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["unit"] = this.unit;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface ICreateMenuResponse_Ingredient {
    name?: string | undefined;
    unit?: string | undefined;
    quantity?: number;
}

export class CreateMenuResponse_MenuItem implements ICreateMenuResponse_MenuItem {
    id?: string;
    name?: string | undefined;
    price?: number;
    ingredients?: CreateMenuResponse_Ingredient[] | undefined;

    constructor(data?: ICreateMenuResponse_MenuItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.price = _data["price"];
            if (Array.isArray(_data["ingredients"])) {
                this.ingredients = [] as any;
                for (let item of _data["ingredients"])
                    this.ingredients!.push(CreateMenuResponse_Ingredient.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateMenuResponse_MenuItem {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMenuResponse_MenuItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["price"] = this.price;
        if (Array.isArray(this.ingredients)) {
            data["ingredients"] = [];
            for (let item of this.ingredients)
                data["ingredients"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateMenuResponse_MenuItem {
    id?: string;
    name?: string | undefined;
    price?: number;
    ingredients?: CreateMenuResponse_Ingredient[] | undefined;
}

export class GetIngredientResponse implements IGetIngredientResponse {
    name?: string | undefined;
    unit?: string | undefined;

    constructor(data?: IGetIngredientResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.unit = _data["unit"];
        }
    }

    static fromJS(data: any): GetIngredientResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetIngredientResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["unit"] = this.unit;
        return data;
    }
}

export interface IGetIngredientResponse {
    name?: string | undefined;
    unit?: string | undefined;
}

export class GetMenusResponse implements IGetMenusResponse {
    id?: string;
    name?: string | undefined;
    menuItems?: GetMenusResponse_MenuItem[] | undefined;

    constructor(data?: IGetMenusResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["menuItems"])) {
                this.menuItems = [] as any;
                for (let item of _data["menuItems"])
                    this.menuItems!.push(GetMenusResponse_MenuItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetMenusResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetMenusResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.menuItems)) {
            data["menuItems"] = [];
            for (let item of this.menuItems)
                data["menuItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetMenusResponse {
    id?: string;
    name?: string | undefined;
    menuItems?: GetMenusResponse_MenuItem[] | undefined;
}

export class GetMenusResponse_Ingredient implements IGetMenusResponse_Ingredient {
    name?: string | undefined;
    unit?: string | undefined;
    quantity?: number;

    constructor(data?: IGetMenusResponse_Ingredient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.unit = _data["unit"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): GetMenusResponse_Ingredient {
        data = typeof data === 'object' ? data : {};
        let result = new GetMenusResponse_Ingredient();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["unit"] = this.unit;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface IGetMenusResponse_Ingredient {
    name?: string | undefined;
    unit?: string | undefined;
    quantity?: number;
}

export class GetMenusResponse_MenuItem implements IGetMenusResponse_MenuItem {
    menuItemId?: string;
    name?: string | undefined;
    price?: number;
    ingredients?: GetMenusResponse_Ingredient[] | undefined;

    constructor(data?: IGetMenusResponse_MenuItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.menuItemId = _data["menuItemId"];
            this.name = _data["name"];
            this.price = _data["price"];
            if (Array.isArray(_data["ingredients"])) {
                this.ingredients = [] as any;
                for (let item of _data["ingredients"])
                    this.ingredients!.push(GetMenusResponse_Ingredient.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetMenusResponse_MenuItem {
        data = typeof data === 'object' ? data : {};
        let result = new GetMenusResponse_MenuItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["menuItemId"] = this.menuItemId;
        data["name"] = this.name;
        data["price"] = this.price;
        if (Array.isArray(this.ingredients)) {
            data["ingredients"] = [];
            for (let item of this.ingredients)
                data["ingredients"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetMenusResponse_MenuItem {
    menuItemId?: string;
    name?: string | undefined;
    price?: number;
    ingredients?: GetMenusResponse_Ingredient[] | undefined;
}

export class CreateOrderRequest implements ICreateOrderRequest {
    orderItems?: CreateOrderRequest_OrderItem[] | undefined;

    constructor(data?: ICreateOrderRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["orderItems"])) {
                this.orderItems = [] as any;
                for (let item of _data["orderItems"])
                    this.orderItems!.push(CreateOrderRequest_OrderItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateOrderRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrderRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.orderItems)) {
            data["orderItems"] = [];
            for (let item of this.orderItems)
                data["orderItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateOrderRequest {
    orderItems?: CreateOrderRequest_OrderItem[] | undefined;
}

export class CreateOrderRequest_OrderItem implements ICreateOrderRequest_OrderItem {
    quantity?: number;
    menuItemId?: string;

    constructor(data?: ICreateOrderRequest_OrderItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.quantity = _data["quantity"];
            this.menuItemId = _data["menuItemId"];
        }
    }

    static fromJS(data: any): CreateOrderRequest_OrderItem {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrderRequest_OrderItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quantity"] = this.quantity;
        data["menuItemId"] = this.menuItemId;
        return data;
    }
}

export interface ICreateOrderRequest_OrderItem {
    quantity?: number;
    menuItemId?: string;
}

export class CreateOrderResponse implements ICreateOrderResponse {
    id?: string;
    dateTime?: Date;
    isCancelled?: boolean;
    orderItems?: CreateOrderResponse_OrderItem[] | undefined;

    constructor(data?: ICreateOrderResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
            this.isCancelled = _data["isCancelled"];
            if (Array.isArray(_data["orderItems"])) {
                this.orderItems = [] as any;
                for (let item of _data["orderItems"])
                    this.orderItems!.push(CreateOrderResponse_OrderItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateOrderResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrderResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["isCancelled"] = this.isCancelled;
        if (Array.isArray(this.orderItems)) {
            data["orderItems"] = [];
            for (let item of this.orderItems)
                data["orderItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateOrderResponse {
    id?: string;
    dateTime?: Date;
    isCancelled?: boolean;
    orderItems?: CreateOrderResponse_OrderItem[] | undefined;
}

export class CreateOrderResponse_OrderItem implements ICreateOrderResponse_OrderItem {
    menuItemId?: string;
    quantity?: number;

    constructor(data?: ICreateOrderResponse_OrderItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.menuItemId = _data["menuItemId"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): CreateOrderResponse_OrderItem {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrderResponse_OrderItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["menuItemId"] = this.menuItemId;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface ICreateOrderResponse_OrderItem {
    menuItemId?: string;
    quantity?: number;
}

export class GetOrderByIdResponse implements IGetOrderByIdResponse {
    name?: string | undefined;
    quantity?: number;
    orderTime?: Date;
    isCancelled?: boolean;

    constructor(data?: IGetOrderByIdResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.quantity = _data["quantity"];
            this.orderTime = _data["orderTime"] ? new Date(_data["orderTime"].toString()) : <any>undefined;
            this.isCancelled = _data["isCancelled"];
        }
    }

    static fromJS(data: any): GetOrderByIdResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetOrderByIdResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["quantity"] = this.quantity;
        data["orderTime"] = this.orderTime ? this.orderTime.toISOString() : <any>undefined;
        data["isCancelled"] = this.isCancelled;
        return data;
    }
}

export interface IGetOrderByIdResponse {
    name?: string | undefined;
    quantity?: number;
    orderTime?: Date;
    isCancelled?: boolean;
}

export class GetOrdersResponse implements IGetOrdersResponse {
    orders?: GetOrdersResponse_Order[] | undefined;
    totalCount?: number;

    constructor(data?: IGetOrdersResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["orders"])) {
                this.orders = [] as any;
                for (let item of _data["orders"])
                    this.orders!.push(GetOrdersResponse_Order.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GetOrdersResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetOrdersResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.orders)) {
            data["orders"] = [];
            for (let item of this.orders)
                data["orders"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IGetOrdersResponse {
    orders?: GetOrdersResponse_Order[] | undefined;
    totalCount?: number;
}

export class GetOrdersResponse_Order implements IGetOrdersResponse_Order {
    orderId?: string;
    orderTime?: Date;
    cancelledTime?: Date | undefined;
    isCancelled?: boolean;
    orderItems?: GetOrdersResponse_OrderItem[] | undefined;
    total?: number;

    constructor(data?: IGetOrdersResponse_Order) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.orderTime = _data["orderTime"] ? new Date(_data["orderTime"].toString()) : <any>undefined;
            this.cancelledTime = _data["cancelledTime"] ? new Date(_data["cancelledTime"].toString()) : <any>undefined;
            this.isCancelled = _data["isCancelled"];
            if (Array.isArray(_data["orderItems"])) {
                this.orderItems = [] as any;
                for (let item of _data["orderItems"])
                    this.orderItems!.push(GetOrdersResponse_OrderItem.fromJS(item));
            }
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): GetOrdersResponse_Order {
        data = typeof data === 'object' ? data : {};
        let result = new GetOrdersResponse_Order();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["orderTime"] = this.orderTime ? this.orderTime.toISOString() : <any>undefined;
        data["cancelledTime"] = this.cancelledTime ? this.cancelledTime.toISOString() : <any>undefined;
        data["isCancelled"] = this.isCancelled;
        if (Array.isArray(this.orderItems)) {
            data["orderItems"] = [];
            for (let item of this.orderItems)
                data["orderItems"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data;
    }
}

export interface IGetOrdersResponse_Order {
    orderId?: string;
    orderTime?: Date;
    cancelledTime?: Date | undefined;
    isCancelled?: boolean;
    orderItems?: GetOrdersResponse_OrderItem[] | undefined;
    total?: number;
}

export class GetOrdersResponse_OrderItem implements IGetOrdersResponse_OrderItem {
    menuItemId?: string;
    quantity?: number;
    menuItemName?: string | undefined;
    price?: number;
    sum?: number;

    constructor(data?: IGetOrdersResponse_OrderItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.menuItemId = _data["menuItemId"];
            this.quantity = _data["quantity"];
            this.menuItemName = _data["menuItemName"];
            this.price = _data["price"];
            this.sum = _data["sum"];
        }
    }

    static fromJS(data: any): GetOrdersResponse_OrderItem {
        data = typeof data === 'object' ? data : {};
        let result = new GetOrdersResponse_OrderItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["menuItemId"] = this.menuItemId;
        data["quantity"] = this.quantity;
        data["menuItemName"] = this.menuItemName;
        data["price"] = this.price;
        data["sum"] = this.sum;
        return data;
    }
}

export interface IGetOrdersResponse_OrderItem {
    menuItemId?: string;
    quantity?: number;
    menuItemName?: string | undefined;
    price?: number;
    sum?: number;
}

export class AssignManagerRequest implements IAssignManagerRequest {
    userId?: string;

    constructor(data?: IAssignManagerRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): AssignManagerRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AssignManagerRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        return data;
    }
}

export interface IAssignManagerRequest {
    userId?: string;
}

export class CreateEmployeeRequest implements ICreateEmployeeRequest {
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    city?: string | undefined;
    employeePositions?: string[] | undefined;

    constructor(data?: ICreateEmployeeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.city = _data["city"];
            if (Array.isArray(_data["employeePositions"])) {
                this.employeePositions = [] as any;
                for (let item of _data["employeePositions"])
                    this.employeePositions!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateEmployeeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEmployeeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["city"] = this.city;
        if (Array.isArray(this.employeePositions)) {
            data["employeePositions"] = [];
            for (let item of this.employeePositions)
                data["employeePositions"].push(item);
        }
        return data;
    }
}

export interface ICreateEmployeeRequest {
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    city?: string | undefined;
    employeePositions?: string[] | undefined;
}

export class CreateEmployeeResponse implements ICreateEmployeeResponse {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    city?: string | undefined;
    employeePositions?: string[] | undefined;

    constructor(data?: ICreateEmployeeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.city = _data["city"];
            if (Array.isArray(_data["employeePositions"])) {
                this.employeePositions = [] as any;
                for (let item of _data["employeePositions"])
                    this.employeePositions!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateEmployeeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEmployeeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["city"] = this.city;
        if (Array.isArray(this.employeePositions)) {
            data["employeePositions"] = [];
            for (let item of this.employeePositions)
                data["employeePositions"].push(item);
        }
        return data;
    }
}

export interface ICreateEmployeeResponse {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    city?: string | undefined;
    employeePositions?: string[] | undefined;
}

export class CreateRestaurantRequest implements ICreateRestaurantRequest {
    address?: Address;
    employees?: CreateRestaurantRequest_Employee[] | undefined;

    constructor(data?: ICreateRestaurantRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"] ? Address.fromJS(_data["address"]) : <any>undefined;
            if (Array.isArray(_data["employees"])) {
                this.employees = [] as any;
                for (let item of _data["employees"])
                    this.employees!.push(CreateRestaurantRequest_Employee.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateRestaurantRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRestaurantRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        if (Array.isArray(this.employees)) {
            data["employees"] = [];
            for (let item of this.employees)
                data["employees"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateRestaurantRequest {
    address?: Address;
    employees?: CreateRestaurantRequest_Employee[] | undefined;
}

export class CreateRestaurantRequest_Employee implements ICreateRestaurantRequest_Employee {
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    city?: string | undefined;
    employeePositions?: CreateRestaurantRequest_EmployeePosition[] | undefined;

    constructor(data?: ICreateRestaurantRequest_Employee) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.city = _data["city"];
            if (Array.isArray(_data["employeePositions"])) {
                this.employeePositions = [] as any;
                for (let item of _data["employeePositions"])
                    this.employeePositions!.push(CreateRestaurantRequest_EmployeePosition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateRestaurantRequest_Employee {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRestaurantRequest_Employee();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["city"] = this.city;
        if (Array.isArray(this.employeePositions)) {
            data["employeePositions"] = [];
            for (let item of this.employeePositions)
                data["employeePositions"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateRestaurantRequest_Employee {
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    city?: string | undefined;
    employeePositions?: CreateRestaurantRequest_EmployeePosition[] | undefined;
}

export class CreateRestaurantRequest_EmployeePosition implements ICreateRestaurantRequest_EmployeePosition {
    position?: string | undefined;

    constructor(data?: ICreateRestaurantRequest_EmployeePosition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.position = _data["position"];
        }
    }

    static fromJS(data: any): CreateRestaurantRequest_EmployeePosition {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRestaurantRequest_EmployeePosition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["position"] = this.position;
        return data;
    }
}

export interface ICreateRestaurantRequest_EmployeePosition {
    position?: string | undefined;
}

export class CreateRestaurantResponse implements ICreateRestaurantResponse {
    id?: string;
    address?: Address;
    orderIds?: string[] | undefined;
    employees?: CreateRestaurantResponse_Employee[] | undefined;
    managers?: CreateRestaurantResponse_Manager[] | undefined;

    constructor(data?: ICreateRestaurantResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.address = _data["address"] ? Address.fromJS(_data["address"]) : <any>undefined;
            if (Array.isArray(_data["orderIds"])) {
                this.orderIds = [] as any;
                for (let item of _data["orderIds"])
                    this.orderIds!.push(item);
            }
            if (Array.isArray(_data["employees"])) {
                this.employees = [] as any;
                for (let item of _data["employees"])
                    this.employees!.push(CreateRestaurantResponse_Employee.fromJS(item));
            }
            if (Array.isArray(_data["managers"])) {
                this.managers = [] as any;
                for (let item of _data["managers"])
                    this.managers!.push(CreateRestaurantResponse_Manager.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateRestaurantResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRestaurantResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        if (Array.isArray(this.orderIds)) {
            data["orderIds"] = [];
            for (let item of this.orderIds)
                data["orderIds"].push(item);
        }
        if (Array.isArray(this.employees)) {
            data["employees"] = [];
            for (let item of this.employees)
                data["employees"].push(item.toJSON());
        }
        if (Array.isArray(this.managers)) {
            data["managers"] = [];
            for (let item of this.managers)
                data["managers"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateRestaurantResponse {
    id?: string;
    address?: Address;
    orderIds?: string[] | undefined;
    employees?: CreateRestaurantResponse_Employee[] | undefined;
    managers?: CreateRestaurantResponse_Manager[] | undefined;
}

export class CreateRestaurantResponse_Employee implements ICreateRestaurantResponse_Employee {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    city?: string | undefined;
    employeePositions?: CreateRestaurantResponse_EmployeePosition[] | undefined;

    constructor(data?: ICreateRestaurantResponse_Employee) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.city = _data["city"];
            if (Array.isArray(_data["employeePositions"])) {
                this.employeePositions = [] as any;
                for (let item of _data["employeePositions"])
                    this.employeePositions!.push(CreateRestaurantResponse_EmployeePosition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateRestaurantResponse_Employee {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRestaurantResponse_Employee();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["city"] = this.city;
        if (Array.isArray(this.employeePositions)) {
            data["employeePositions"] = [];
            for (let item of this.employeePositions)
                data["employeePositions"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateRestaurantResponse_Employee {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    city?: string | undefined;
    employeePositions?: CreateRestaurantResponse_EmployeePosition[] | undefined;
}

export class CreateRestaurantResponse_EmployeePosition implements ICreateRestaurantResponse_EmployeePosition {
    position?: string | undefined;

    constructor(data?: ICreateRestaurantResponse_EmployeePosition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.position = _data["position"];
        }
    }

    static fromJS(data: any): CreateRestaurantResponse_EmployeePosition {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRestaurantResponse_EmployeePosition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["position"] = this.position;
        return data;
    }
}

export interface ICreateRestaurantResponse_EmployeePosition {
    position?: string | undefined;
}

export class CreateRestaurantResponse_Manager implements ICreateRestaurantResponse_Manager {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;

    constructor(data?: ICreateRestaurantResponse_Manager) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): CreateRestaurantResponse_Manager {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRestaurantResponse_Manager();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        return data;
    }
}

export interface ICreateRestaurantResponse_Manager {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
}

export class CreateScheduleRequest implements ICreateScheduleRequest {
    title?: string | undefined;
    priority?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    employeeIds?: string[] | undefined;

    constructor(data?: ICreateScheduleRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.priority = _data["priority"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["employeeIds"])) {
                this.employeeIds = [] as any;
                for (let item of _data["employeeIds"])
                    this.employeeIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateScheduleRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateScheduleRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["priority"] = this.priority;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        if (Array.isArray(this.employeeIds)) {
            data["employeeIds"] = [];
            for (let item of this.employeeIds)
                data["employeeIds"].push(item);
        }
        return data;
    }
}

export interface ICreateScheduleRequest {
    title?: string | undefined;
    priority?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    employeeIds?: string[] | undefined;
}

export class DeleteScheduleRequest implements IDeleteScheduleRequest {
    scheduleId?: string;

    constructor(data?: IDeleteScheduleRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scheduleId = _data["scheduleId"];
        }
    }

    static fromJS(data: any): DeleteScheduleRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteScheduleRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scheduleId"] = this.scheduleId;
        return data;
    }
}

export interface IDeleteScheduleRequest {
    scheduleId?: string;
}

export class EditEmployeeRequest implements IEditEmployeeRequest {
    employeeId?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    city?: string | undefined;
    employeePositions?: string[] | undefined;

    constructor(data?: IEditEmployeeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeId = _data["employeeId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.city = _data["city"];
            if (Array.isArray(_data["employeePositions"])) {
                this.employeePositions = [] as any;
                for (let item of _data["employeePositions"])
                    this.employeePositions!.push(item);
            }
        }
    }

    static fromJS(data: any): EditEmployeeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EditEmployeeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeId"] = this.employeeId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["city"] = this.city;
        if (Array.isArray(this.employeePositions)) {
            data["employeePositions"] = [];
            for (let item of this.employeePositions)
                data["employeePositions"].push(item);
        }
        return data;
    }
}

export interface IEditEmployeeRequest {
    employeeId?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    city?: string | undefined;
    employeePositions?: string[] | undefined;
}

export class EditScheduleRequest implements IEditScheduleRequest {
    scheduleId?: string;
    title?: string | undefined;
    priority?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    employeeIds?: string[] | undefined;

    constructor(data?: IEditScheduleRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scheduleId = _data["scheduleId"];
            this.title = _data["title"];
            this.priority = _data["priority"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["employeeIds"])) {
                this.employeeIds = [] as any;
                for (let item of _data["employeeIds"])
                    this.employeeIds!.push(item);
            }
        }
    }

    static fromJS(data: any): EditScheduleRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EditScheduleRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scheduleId"] = this.scheduleId;
        data["title"] = this.title;
        data["priority"] = this.priority;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        if (Array.isArray(this.employeeIds)) {
            data["employeeIds"] = [];
            for (let item of this.employeeIds)
                data["employeeIds"].push(item);
        }
        return data;
    }
}

export interface IEditScheduleRequest {
    scheduleId?: string;
    title?: string | undefined;
    priority?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    employeeIds?: string[] | undefined;
}

export class GetEmployeesResponse implements IGetEmployeesResponse {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    city?: string | undefined;
    supervisors?: string | undefined;
    positions?: string[] | undefined;

    constructor(data?: IGetEmployeesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.city = _data["city"];
            this.supervisors = _data["supervisors"];
            if (Array.isArray(_data["positions"])) {
                this.positions = [] as any;
                for (let item of _data["positions"])
                    this.positions!.push(item);
            }
        }
    }

    static fromJS(data: any): GetEmployeesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetEmployeesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["city"] = this.city;
        data["supervisors"] = this.supervisors;
        if (Array.isArray(this.positions)) {
            data["positions"] = [];
            for (let item of this.positions)
                data["positions"].push(item);
        }
        return data;
    }
}

export interface IGetEmployeesResponse {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    city?: string | undefined;
    supervisors?: string | undefined;
    positions?: string[] | undefined;
}

export class GetScheduleResponse implements IGetScheduleResponse {
    scheduleId?: string;
    title?: string | undefined;
    priority?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    employeeIds?: string[] | undefined;

    constructor(data?: IGetScheduleResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scheduleId = _data["scheduleId"];
            this.title = _data["title"];
            this.priority = _data["priority"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["employeeIds"])) {
                this.employeeIds = [] as any;
                for (let item of _data["employeeIds"])
                    this.employeeIds!.push(item);
            }
        }
    }

    static fromJS(data: any): GetScheduleResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetScheduleResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scheduleId"] = this.scheduleId;
        data["title"] = this.title;
        data["priority"] = this.priority;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        if (Array.isArray(this.employeeIds)) {
            data["employeeIds"] = [];
            for (let item of this.employeeIds)
                data["employeeIds"].push(item);
        }
        return data;
    }
}

export interface IGetScheduleResponse {
    scheduleId?: string;
    title?: string | undefined;
    priority?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    employeeIds?: string[] | undefined;
}

export class PackageItem implements IPackageItem {
    packageId?: string;
    destinationRestaurant?: string | undefined;
    manager?: string | undefined;
    regionalManager?: string | undefined;
    sourceRestaurant?: string | undefined;
    courier?: string | undefined;
    originAddress?: Address;
    destinationAddress?: Address;
    status?: string | undefined;
    message?: string | undefined;
    isUrgent?: boolean;
    ingredients?: PackageItem_Ingredient[] | undefined;
    until?: Date | undefined;

    constructor(data?: IPackageItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.packageId = _data["packageId"];
            this.destinationRestaurant = _data["destinationRestaurant"];
            this.manager = _data["manager"];
            this.regionalManager = _data["regionalManager"];
            this.sourceRestaurant = _data["sourceRestaurant"];
            this.courier = _data["courier"];
            this.originAddress = _data["originAddress"] ? Address.fromJS(_data["originAddress"]) : <any>undefined;
            this.destinationAddress = _data["destinationAddress"] ? Address.fromJS(_data["destinationAddress"]) : <any>undefined;
            this.status = _data["status"];
            this.message = _data["message"];
            this.isUrgent = _data["isUrgent"];
            if (Array.isArray(_data["ingredients"])) {
                this.ingredients = [] as any;
                for (let item of _data["ingredients"])
                    this.ingredients!.push(PackageItem_Ingredient.fromJS(item));
            }
            this.until = _data["until"] ? new Date(_data["until"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PackageItem {
        data = typeof data === 'object' ? data : {};
        let result = new PackageItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["packageId"] = this.packageId;
        data["destinationRestaurant"] = this.destinationRestaurant;
        data["manager"] = this.manager;
        data["regionalManager"] = this.regionalManager;
        data["sourceRestaurant"] = this.sourceRestaurant;
        data["courier"] = this.courier;
        data["originAddress"] = this.originAddress ? this.originAddress.toJSON() : <any>undefined;
        data["destinationAddress"] = this.destinationAddress ? this.destinationAddress.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["message"] = this.message;
        data["isUrgent"] = this.isUrgent;
        if (Array.isArray(this.ingredients)) {
            data["ingredients"] = [];
            for (let item of this.ingredients)
                data["ingredients"].push(item.toJSON());
        }
        data["until"] = this.until ? this.until.toISOString() : <any>undefined;
        return data;
    }
}

export interface IPackageItem {
    packageId?: string;
    destinationRestaurant?: string | undefined;
    manager?: string | undefined;
    regionalManager?: string | undefined;
    sourceRestaurant?: string | undefined;
    courier?: string | undefined;
    originAddress?: Address;
    destinationAddress?: Address;
    status?: string | undefined;
    message?: string | undefined;
    isUrgent?: boolean;
    ingredients?: PackageItem_Ingredient[] | undefined;
    until?: Date | undefined;
}

export class PackageItem_Ingredient implements IPackageItem_Ingredient {
    name?: string | undefined;
    unit?: string | undefined;
    quantity?: number;

    constructor(data?: IPackageItem_Ingredient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.unit = _data["unit"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): PackageItem_Ingredient {
        data = typeof data === 'object' ? data : {};
        let result = new PackageItem_Ingredient();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["unit"] = this.unit;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface IPackageItem_Ingredient {
    name?: string | undefined;
    unit?: string | undefined;
    quantity?: number;
}

export class CreatePackageRequest implements ICreatePackageRequest {
    ingredients?: CreatePackageRequest_Ingredient[] | undefined;
    until?: Date;
    isUrgent?: boolean;
    message?: string | undefined;

    constructor(data?: ICreatePackageRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ingredients"])) {
                this.ingredients = [] as any;
                for (let item of _data["ingredients"])
                    this.ingredients!.push(CreatePackageRequest_Ingredient.fromJS(item));
            }
            this.until = _data["until"] ? new Date(_data["until"].toString()) : <any>undefined;
            this.isUrgent = _data["isUrgent"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): CreatePackageRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePackageRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ingredients)) {
            data["ingredients"] = [];
            for (let item of this.ingredients)
                data["ingredients"].push(item.toJSON());
        }
        data["until"] = this.until ? this.until.toISOString() : <any>undefined;
        data["isUrgent"] = this.isUrgent;
        data["message"] = this.message;
        return data;
    }
}

export interface ICreatePackageRequest {
    ingredients?: CreatePackageRequest_Ingredient[] | undefined;
    until?: Date;
    isUrgent?: boolean;
    message?: string | undefined;
}

export class CreatePackageRequest_Ingredient implements ICreatePackageRequest_Ingredient {
    name?: string | undefined;
    unit?: string | undefined;
    quantity?: number;

    constructor(data?: ICreatePackageRequest_Ingredient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.unit = _data["unit"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): CreatePackageRequest_Ingredient {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePackageRequest_Ingredient();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["unit"] = this.unit;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface ICreatePackageRequest_Ingredient {
    name?: string | undefined;
    unit?: string | undefined;
    quantity?: number;
}

export class GetPackagesResponse implements IGetPackagesResponse {
    packages?: PackageItem[] | undefined;
    total?: number;

    constructor(data?: IGetPackagesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["packages"])) {
                this.packages = [] as any;
                for (let item of _data["packages"])
                    this.packages!.push(PackageItem.fromJS(item));
            }
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): GetPackagesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetPackagesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.packages)) {
            data["packages"] = [];
            for (let item of this.packages)
                data["packages"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data;
    }
}

export interface IGetPackagesResponse {
    packages?: PackageItem[] | undefined;
    total?: number;
}

export class WeatherForecast implements IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    readonly temperatureF?: number;
    summary?: string | undefined;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.temperatureC = _data["temperatureC"];
            (<any>this).temperatureF = _data["temperatureF"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? formatDate(this.date) : <any>undefined;
        data["temperatureC"] = this.temperatureC;
        data["temperatureF"] = this.temperatureF;
        data["summary"] = this.summary;
        return data;
    }
}

export interface IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}